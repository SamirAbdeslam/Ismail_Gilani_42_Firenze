

						*MINISHELL*



--------------------------------------------------------------------------------------------------------------------------------------

1. STRUTTURA BASE DEL SHELL

Obiettivo: Creare un loop principale che legge input e mostra un prompt.
Funzioni chiave:

	readline() (per leggere l'input con supporto history)

	add_history() (per salvare i comandi nella history)

Approfondimenti:

	Come funziona un REPL (Read-Eval-Print Loop)?
	int main() 
	{
    		char *input;

    		while (1) 
    		{
        		// 1. READ
        		input = readline("minishell$ ");
       		if (!input) 
       		 	break;  // Ctrl+D
        
        		// 2. EVAL 
        		if (strcmp(input, "exit") == 0) 
        		{
            			free(input);
            			break;
        		}
        		// 3. PRINT
        		printf("Hai scritto: %s\n", input);  // 3. PRINT
        			add_history(input);  // Aggiunge alla cronologia
        		free(input);  // Libera la memoria
		}
    		return 0;
	}

	Gestione base della memoria (allocare/freeare la stringa da readline).

--------------------------------------------------------------------------------------------------------------------------------------

2. PARSING DEI COMANDI

Obiettivo: Dividere l'input in token (comandi, argomenti, redirezioni, pipe).
Funzioni chiave:

	strtok, strdup, strchr (per splittare l'input)

	Logica per gestire "..." e '...' (ignorare spazi/metacaratteri dentro le quotes)

	Espansione di $VAR e $? (usare getenv e una variabile globale per l'ultimo exit status)

Approfondimenti:

	Come gestire le quote nidificate?

	Differenza tra "$VAR" (espande) e '$VAR' (non espande).

--------------------------------------------------------------------------------------------------------------------------------------

3. GESTIONE DELLE REDIREZIONI E PIPE

Obiettivo: Implementare <, >, >>, << e |.
Funzioni chiave:

	open, close, dup2 (per redirezioni)

	pipe, fork (per pipeline)

	access (per verificare i permessi dei file)

Approfondimenti:

	Come funziona la manipolazione dei file descriptor?

	Come gestire << (here-document)? (leggere input fino a un delimitatore)

--------------------------------------------------------------------------------------------------------------------------------------

4. ESECUZIONE DEI COMANDI

Obiettivo: Eseguire comandi esterni e built-in.
Built-in da implementare:

	echo, cd, pwd, export, unset, env, exit

Funzioni chiave:

	execve (per lanciare programmi esterni)

	fork + waitpid (per eseguire in foreground)

	getcwd, chdir (per cd e pwd)

Approfondimenti:

	Come cercare l'eseguibile nel PATH? (split PATH e provare access + execve in ogni cartella)

	Come gestire exit con un codice di uscita?

--------------------------------------------------------------------------------------------------------------------------------------

5. GESTIONE DEI SEGNALI (ctrl-C, ctrl-D, ctrl-)

Obiettivo: Far comportare i segnali come in bash.
Funzioni chiave:

	signal / sigaction (per catturare SIGINT, SIGQUIT)

	Variabile globale volatile sig_atomic_t (per comunicare tra handler e main loop)

Approfondimenti:

	PerchÃ© usare sigaction invece di signal?

	Come evitare race condition con i segnali?

--------------------------------------------------------------------------------------------------------------------------------------

6. PULIZIA E GESTIONE DEGLI ERRORI

Obiettivo: Evitare memory leak e gestire errori gracefully.
Funzioni chiave:

	free (per liberare memoria)

	perror / strerror (per errori di sistema)

	isatty (per verificare se siamo in una terminale interattiva)

Approfondimenti:

	Come debugare file descriptor leak? (usare lsof o valgrind)

--------------------------------------------------------------------------------------------------------------------------------------

7. TESTING E DEBUGGING

Obiettivo: Assicurarsi che tutto funzioni come bash.
Strumenti utili:

	valgrind (per memory leak)

	strace/ltrace (per vedere chiamate di sistema)

	Script di test (confrontare output con bash)
	
--------------------------------------------------------------------------------------------------------------------------------------

SCALETTA RIASSUNTIVA

	Loop principale (REPL con readline + prompt)

	Tokenizzazione (split comandi, gestione quote)

	Redirezioni e pipe (dup2, pipe, fork)

	Esecuzione (built-in + execve)

	Segnali (SIGINT, SIGQUIT, SIGTERM)

	Pulizia (free, error handling)

	Testing (confronto con bash)
	
	
	
	
	
	
	
	
	
	
	
	
